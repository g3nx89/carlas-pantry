# Code Handoff Protocol

> **Cross-references**: `recipes-advanced.md` (Handoff Preparation Pattern + naming audit recipe), `design-rules.md` (Code-readiness SHOULD rules #11-15), `st-integration.md` (Naming Audit Reasoning template), `tool-playbook.md` (Complementary Workflow — downstream Official MCP tools)

When the design session is complete and the design will be implemented as code,
run this protocol to prepare the Figma artifact for downstream consumption by the
coding agent. The coding agent uses `get_design_context` (Official MCP) to extract
framework-ready specs (React, SwiftUI, Compose, etc.) and the `implement-design`
Agent Skill to translate them into production code.

### TIER System — Componentization Depth

Without Code Connect (requires Organization/Enterprise), `get_design_context` returns
component names, variant properties, and descriptions but cannot provide bidirectional
design-code mappings. The TIER system scales componentization effort to match the
plan's capabilities:

| TIER | Name | What It Includes | When to Use |
|------|------|-----------------|-------------|
| **TIER 1** | Naming + Tokens + Inventory | Steps 1-6 below (naming audit, token alignment, UI kit preference, health check). No custom component creation | Always — minimum viable handoff |
| **TIER 2** | Smart Componentization | TIER 1 + create components only for elements meeting all 3 Smart Componentization Criteria (see below). Typically 5-8 components | Recommended — best effort-to-value ratio without Enterprise |
| **TIER 3** | Heavy Componentization | TIER 1 + componentize every recurring element regardless of criteria. Full component library | Optional — when design system completeness is prioritized over speed |

**Default**: TIER 2 (Smart Componentization). The user may override via explicit request.

### Smart Componentization Criteria (TIER 2)

A design element qualifies for componentization ONLY when ALL three gates pass:

| # | Gate | Question | Pass Condition |
|---|------|----------|----------------|
| 1 | **Recurrence** | Does this element appear in 3+ screens? | Count >= 3 distinct screens |
| 2 | **Behavioral Variants** | Does it have meaningful state/size/type variations? | At least 2 variants (e.g., primary/secondary, active/inactive, sm/md/lg) |
| 3 | **Codebase Match** | Does the target codebase have (or will have) a corresponding component? | Confirmed or planned code component exists |

Elements failing any gate remain as styled frames with proper naming and token binding (TIER 1 treatment).

**Examples**:
- `PrimaryButton` — appears in 8 screens, has size + state variants, maps to `<Button variant="primary">` → **PASS** (all 3 gates)
- `PageHeader` — appears in 2 screens, no variants → **FAIL** (gate 1: recurrence < 3)
- `HeroBanner` — appears in 5 screens, has variants, but is a one-off layout section with no code component → **FAIL** (gate 3: no codebase match)

**Load**: `recipes-advanced.md` (Handoff Preparation Pattern)

## Steps

1. **Naming audit** — run the Handoff Naming Audit recipe via `figma_execute` to
   check all components for non-PascalCase names and uppercase variant property keys
2. **Fix naming** — rename components to match the target codebase's component
   naming convention (typically PascalCase: `ProductCard`, not `product card`
   or `Frame 42`); rename variant property keys to lowercase (`size`, `variant`,
   `state`)
3. **Exception descriptions** — `figma_set_description` ONLY where the Figma name
   must differ from the code name:
   ```
   Code name: CallToActionButton
   Note: Figma name "CTA Button" differs for brevity
   ```
4. **Token alignment** — verify variable/token names correspond to the codebase
   token system (e.g., `color/primary/500` -> `--color-primary-500`)
5. **UI kit preference** — where possible, compose with M3/Apple/SDS library
   components that have automatic Code Connect on Professional+ plans
6. **Health check** — `figma_audit_design_system` for final naming, token, and
   consistency scores

> **ST trigger**: When the naming audit (step 1) surfaces >5 issues with ambiguous false positives (CTA, 2XL, etc.), activate ST with a TAO Loop to reason through each flagged item: classify as true positive, false positive, or ambiguous. See [`st-integration.md#template-naming-audit-reasoning`].

7. **Handoff Manifest** (TIER 2/3) — generate `specs/figma/handoff-manifest.md` with the
   structured data the coding agent needs to bridge Figma → code. Template:

   ```markdown
   # Handoff Manifest
   <!-- Generated by figma-console-mastery Code Handoff Protocol -->
   <!-- TIER: [1|2|3] | Date: [ISO date] | Figma file: [name] -->

   ## Screen Inventory

   | # | Screen Name | Figma Node ID | Dimensions | Route (if known) |
   |---|-------------|---------------|------------|-------------------|
   | 1 | [name]      | [nodeId]       | [WxH]      | [/path]           |

   ## Component-to-Code Mapping (TIER 2/3 only)

   | Figma Component | Code Component | Variant Props | Notes |
   |-----------------|----------------|---------------|-------|
   | [FigmaName]     | [CodeName]     | size, variant | [any naming exceptions] |

   ## Token Mapping

   | Figma Token | Code Token | Value |
   |-------------|------------|-------|
   | color/primary/500 | --color-primary-500 | #6750A4 |

   ## Naming Exceptions

   | Figma Name | Code Name | Reason |
   |------------|-----------|--------|
   | [CTA Button] | [CallToActionButton] | Figma name shortened for brevity |

   ## Health Score

   - Design System Audit: [N]/100
   - Naming compliance: [N]% PascalCase
   - Token coverage: [N]% bound to variables
   ```

   The coding agent reads this manifest to locate screens by node ID, map components
   to code, and resolve token names — without needing Code Connect.

## Multi-Platform Notes

The component name is the cross-platform contract. The coding
agent for each platform searches its own codebase for a component matching the
Figma name. `get_design_context` handles framework-specific translation. For
components where platform names diverge (e.g., Figma `BottomNavigation` vs
SwiftUI `TabView`), use step 3 exception descriptions with platform-specific
code names.

## Preceding Input: UX-NARRATIVE

The `design-narration` skill (`product-definition` plugin) produces a
`UX-NARRATIVE.md` from Figma mockups **before** the handoff workflow. Its pipeline
position is: `refinement (PRD.md) → design-narration (UX-NARRATIVE.md) → specification → handoff`.

When available, the UX-NARRATIVE feeds into this protocol at two points:

1. **Smart Componentization Analysis** (Step 0.5 of Draft-to-Handoff) — the narrative's
   per-screen state/interaction descriptions directly inform **Gate 2** (behavioral
   variants). An element documented as having active/inactive/error states in the
   narrative is a confirmed Gate 2 pass without manual inspection.
2. **Handoff Manifest** — the manifest references the UX-NARRATIVE path so the coding
   agent has both structural (manifest) and behavioral (narrative) context.

- **UX-NARRATIVE** = *how* it behaves (flows, states, interactions) — produced BEFORE handoff
- **Handoff Manifest** = *what* to build (structure, components, tokens) — produced DURING handoff

The UX-NARRATIVE is recommended but not required. The handoff protocol functions
fully without it — Gate 2 is evaluated by visual inspection of Figma nodes instead.
The narrative adds precision and reduces manual variant discovery effort.

## Scope

This protocol prepares the Figma artifact for downstream consumption.
Actual code generation is performed by the `implement-design` Agent Skill via Official MCP.
For plan-specific availability of downstream tools, see `tool-playbook.md`
(Complementary Workflow).
