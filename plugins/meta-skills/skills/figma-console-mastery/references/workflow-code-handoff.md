# Code Handoff Protocol

> **Cross-references**: `recipes-advanced.md` (Handoff Preparation Pattern + naming audit recipe), `design-rules.md` (Code-readiness SHOULD rules #11-14), `st-integration.md` (Naming Audit Reasoning template), `quality-audit-scripts.md` (Script I: Prototype Connection Extraction, Script H: UX Copy Quality)

When the design session is complete and the design will be implemented as code,
run this protocol to prepare the Figma artifact for downstream consumption by a
coding agent. The coding agent may use design extraction tools (e.g., external design-to-code
tools, or direct Plugin API traversal via `figma_execute`) to read the design. This protocol
ensures designs are structurally ready for extraction by any downstream tool.

### TIER System — Componentization Depth

Design extraction tools (whether via external design-to-code services or direct Plugin API reads)
can read component names, variant properties, and descriptions. The TIER system scales
componentization effort based on the design's downstream usage:

| TIER | Name | What It Includes | When to Use |
|------|------|-----------------|-------------|
| **TIER 1** | Naming + Tokens + Inventory | Steps 1-6 below (naming audit, token alignment, UI kit preference, health check). No custom component creation | Always — minimum viable handoff |
| **TIER 2** | Smart Componentization | TIER 1 + create components only for elements meeting all 3 Smart Componentization Criteria (see below). Typically 5-8 components | Recommended — best effort-to-value ratio without Enterprise |
| **TIER 3** | Heavy Componentization | TIER 1 + componentize every recurring element regardless of criteria. Full component library | Optional — when design system completeness is prioritized over speed |

**Default**: TIER 2 (Smart Componentization). The user may override via explicit request.

### Smart Componentization Criteria (TIER 2)

A design element qualifies for componentization ONLY when ALL three gates pass:

| # | Gate | Question | Pass Condition |
|---|------|----------|----------------|
| 1 | **Recurrence** | Does this element appear in 3+ screens? | Count >= 3 distinct screens |
| 2 | **Behavioral Variants** | Does it have meaningful state/size/type variations? | At least 2 variants (e.g., primary/secondary, active/inactive, sm/md/lg) |
| 3 | **Codebase Match** | Does the target codebase have (or will have) a corresponding component? | Confirmed or planned code component exists |

Elements failing any gate remain as styled frames with proper naming and token binding (TIER 1 treatment).

**Examples**:
- `PrimaryButton` — appears in 8 screens, has size + state variants, maps to `<Button variant="primary">` → **PASS** (all 3 gates)
- `PageHeader` — appears in 2 screens, no variants → **FAIL** (gate 1: recurrence < 3)
- `HeroBanner` — appears in 5 screens, has variants, but is a one-off layout section with no code component → **FAIL** (gate 3: no codebase match)

**Load**: `recipes-advanced.md` (Handoff Preparation Pattern)

## Steps

1. **Naming audit** — run the Handoff Naming Audit recipe via `figma_execute` to
   check all components for non-PascalCase names and uppercase variant property keys
2. **Fix naming** — rename components to match the target codebase's component
   naming convention (typically PascalCase: `ProductCard`, not `product card`
   or `Frame 42`); rename variant property keys to lowercase (`size`, `variant`,
   `state`)
3. **Exception descriptions** — `figma_set_description` ONLY where the Figma name
   must differ from the code name:
   ```
   Code name: CallToActionButton
   Note: Figma name "CTA Button" differs for brevity
   ```
4. **Token alignment** — verify variable/token names correspond to the codebase
   token system (e.g., `color/primary/500` -> `--color-primary-500`)
5. **Health check** — `figma_audit_design_system` for final naming, token, and
   consistency scores

> **ST trigger**: When the naming audit (step 1) surfaces >5 issues with ambiguous false positives (CTA, 2XL, etc.), activate ST with a TAO Loop to reason through each flagged item: classify as true positive, false positive, or ambiguous. See [`st-integration.md#template-naming-audit-reasoning`].

6. **Handoff Manifest** (TIER 2/3) — generate `specs/figma/handoff-manifest.md` with the
   structured data the coding agent needs to bridge Figma → code. The consuming workflow
   (e.g., design-handoff skill) generates this manifest, not this skill. Template:

   ```markdown
   # Handoff Manifest
   <!-- Generated by figma-console-mastery Code Handoff Protocol -->
   <!-- TIER: [1|2|3] | Date: [ISO date] | Figma file: [name] -->

   ## Screen Inventory

   | # | Screen Name | Figma Node ID | Dimensions | Route (if known) |
   |---|-------------|---------------|------------|-------------------|
   | 1 | [name]      | [nodeId]       | [WxH]      | [/path]           |

   ## Component-to-Code Mapping (TIER 2/3 only)

   | Figma Component | Code Component | Variant Props | Notes |
   |-----------------|----------------|---------------|-------|
   | [FigmaName]     | [CodeName]     | size, variant | [any naming exceptions] |

   ## Token Mapping

   | Figma Token | Code Token | Value |
   |-------------|------------|-------|
   | color/primary/500 | --color-primary-500 | #6750A4 |

   ## Naming Exceptions

   | Figma Name | Code Name | Reason |
   |------------|-----------|--------|
   | [CTA Button] | [CallToActionButton] | Figma name shortened for brevity |

   ## Health Score

   - Design System Audit: [N]/100
   - Naming compliance: [N]% PascalCase
   - Token coverage: [N]% bound to variables

   ## Interaction Specifications

   ### Prototype Connections (auto-extracted via Script I)

   | # | Element | Trigger | Action | Destination | Transition | Duration |
   |---|---------|---------|--------|-------------|------------|----------|
   | 1 | [source name] | ON_CLICK | NAVIGATE | [dest screen] | SMART_ANIMATE | 300ms |

   ### Gesture & Hover Behaviors (manual — not captured by Figma prototype)

   | Element | Gesture/State | Behavior | Notes |
   |---------|--------------|----------|-------|
   | [element] | Long press | [action] | [details] |
   | [element] | Hover | [visual change] | [details] |

   ### Focus & Active States (manual)

   | Element | Focus State | Active State | Tab Order |
   |---------|------------|-------------|-----------|
   | [element] | [visual indicator] | [visual change] | [N] |

   ## Content Specifications

   | Field | Max Characters | Truncation | Empty State | Loading State |
   |-------|---------------|------------|-------------|---------------|
   | [field name] | [N] | [ellipsis/fade/wrap] | [placeholder text] | [skeleton/spinner] |

   ### Error States

   | Field/Screen | Error Condition | Message | Recovery Action |
   |-------------|----------------|---------|-----------------|
   | [field] | [condition] | [error text] | [how to recover] |

   ## Edge Case Specifications

   ### i18n String Expansion

   | Element | Current (EN) | Max Expansion | Overflow Strategy |
   |---------|-------------|---------------|-------------------|
   | [element] | [text] | [1.5x/2x] | [truncate/wrap/resize] |

   ### Degraded Conditions

   | Condition | Affected Elements | Behavior | Fallback |
   |-----------|------------------|----------|----------|
   | Slow connection (>3s) | [elements] | [behavior] | [fallback UI] |
   | Missing data | [elements] | [behavior] | [empty state] |
   | Offline | [elements] | [behavior] | [cached/disabled] |
   ```

   The coding agent reads this manifest to locate screens by node ID, map components
   to code, and resolve token names.

## Behavioral Specification Extraction Steps

These steps populate the Interaction, Content, and Edge Case sections of the Handoff Manifest:

1. **Prototype Connection Extraction (auto)** — Run Script I (`quality-audit-scripts.md` Section 9) per screen. Populates the "Prototype Connections" table automatically from `node.reactions`.

2. **Gesture/Hover/Focus Behaviors (manual prompt)** — Script I captures only Figma prototype connections. For behaviors not captured:
   - Ask user: "Are there gesture interactions (long press, swipe, pinch) not in the prototype?"
   - Ask user: "Are there hover/focus states that should be documented?"
   - Include "Let's discuss this" option per P3.

3. **Content Specifications (heuristic-assisted)** — For each TEXT node in interactive elements:
   - Auto-compute current character count from `.characters.length`
   - Ask user: "What is the max character limit for [field]?" / "How should overflow be handled?"
   - Auto-detect empty state patterns (see Script H, check H3) and prompt user for loading state behavior.

4. **Edge Case Checklist (manual prompt)** — Present checklist to user:
   - i18n: "Will this support multiple languages? Expected max expansion factor?"
   - Degraded conditions: "What happens on slow connection / missing data / offline?"
   - Include "Skip — not applicable" and "Let's discuss this" options.

## Multi-Platform Notes

The component name is the cross-platform contract. The coding agent for each platform
searches its own codebase for a component matching the Figma name. For components where
platform names diverge (e.g., Figma `BottomNavigation` vs SwiftUI `TabView`), use step 3
exception descriptions with platform-specific code names.

## Preceding Input: UX-NARRATIVE

The `design-narration` skill (`product-definition` plugin) produces a
`UX-NARRATIVE.md` from Figma mockups **before** the handoff workflow. Its pipeline
position is: `refinement (PRD.md) → design-narration (UX-NARRATIVE.md) → specification → handoff`.

When available, the UX-NARRATIVE feeds into this protocol at two points:

1. **Smart Componentization Analysis** (Step 0.5 of Draft-to-Handoff) — the narrative's
   per-screen state/interaction descriptions directly inform **Gate 2** (behavioral
   variants). An element documented as having active/inactive/error states in the
   narrative is a confirmed Gate 2 pass without manual inspection.
2. **Handoff Manifest** — the manifest references the UX-NARRATIVE path so the coding
   agent has both structural (manifest) and behavioral (narrative) context.

- **UX-NARRATIVE** = *how* it behaves (flows, states, interactions) — produced BEFORE handoff
- **Handoff Manifest** = *what* to build (structure, components, tokens) — produced DURING handoff

The UX-NARRATIVE is recommended but not required. The handoff protocol functions
fully without it — Gate 2 is evaluated by visual inspection of Figma nodes instead.
The narrative adds precision and reduces manual variant discovery effort.

## Scope

This protocol prepares the Figma artifact for downstream consumption by any coding workflow.
Actual code generation is handled by the consuming workflow (e.g., design-handoff skill in
the product-definition plugin, or custom implementation workflows using Official Figma MCP
or direct Plugin API reads).
