# Code Coverage and Gradle Managed Devices Reference

CLI-only execution of JaCoCo code coverage (instrumented, unit, and merged reports) and Gradle Managed Devices (GMD) for hermetic CI emulator management: device definitions, groups, sharding, and GPU configuration.

> For CI-specific GMD patterns (test tiers, device groups), see ci-pipeline-config.md.

> **TL;DR**: Enable JaCoCo with `isTestCoverageEnabled = true`, merge unit+instrumented via custom `jacocoTestReport` task, use Kover for simpler Kotlin setup (`koverHtmlReport`), enforce thresholds with `jacocoTestCoverageVerification`, define GMD devices in `testOptions.managedDevices`, run with `./gradlew pixel2api30DebugAndroidTest`.

## Code Coverage (JaCoCo)

### Instrumented Coverage

Enable in `debug` build type:

```kotlin
android {
  buildTypes {
    debug {
      isTestCoverageEnabled = true
    }
  }
}
```

Generate report:

```bash
./gradlew createDebugCoverageReport
```

Reports written to:
- `app/build/reports/coverage/debug/`

### Merging Unit + Instrumented Coverage

```kotlin
plugins {
  id("jacoco")
}

jacoco {
  toolVersion = "0.8.11"  // Match your Kotlin/AGP compatibility
}

tasks.register<JacocoReport>("jacocoTestReport") {
  dependsOn("testDebugUnitTest", "connectedDebugAndroidTest")

  val fileFilter = listOf(
    "**/R.class", "**/R$*.class",
    "**/BuildConfig.*", "**/Manifest*.*",
    "**/*Test*.*", "android/**/*.*"
  )

  val buildDir = layout.buildDirectory.get().asFile

  val javaDebugTree = fileTree(
    "${buildDir}/intermediates/classes/debug"
  ) { exclude(fileFilter) }

  val kotlinDebugTree = fileTree(
    "${buildDir}/tmp/kotlin-classes/debug"
  ) { exclude(fileFilter) }

  sourceDirectories.from(files("${project.projectDir}/src/main/java"))
  classDirectories.from(files(javaDebugTree, kotlinDebugTree))
  executionData.from(
    fileTree(dir = buildDir, includes = listOf(
      "jacoco/testDebugUnitTest.exec",
      "outputs/code-coverage/connected/*coverage.ec"
    ))
  )

  reports {
    xml.required.set(true)
    html.required.set(true)
  }
}
```

CLI:

```bash
./gradlew testDebugUnitTest connectedDebugAndroidTest jacocoTestReport
```

### Exclusion Patterns for Generated Code

Comprehensive exclusion list for Dagger/Hilt, Room, DataBinding, and Compose compiler outputs:

```kotlin
val generatedExclusions = listOf(
    // Dagger / Hilt
    "**/Dagger*Component*.class", "**/Dagger*Subcomponent*.class",
    "**/*_MembersInjector.class", "**/*Module_*Factory.class",
    "**/*_Factory*.class", "**/*Hilt*.class",
    // Room
    "**/*_Impl.class", "**/*_Impl$*.class",
    // DataBinding
    "**/databinding/*Binding.class", "**/databinding/*BindingImpl.class",
    "**/BR.class", "**/BR$*.class",
    // Android generated
    "**/R.class", "**/R$*.class", "**/BuildConfig.class", "**/Manifest*.class",
    // Compose compiler
    "**/*ComposableSingletons*.class", "**/*\$lambda-*.class"
)
```

Apply to JaCoCo report tasks via `classDirectories.setFrom(fileTree(...) { exclude(generatedExclusions) })`.

**Gotcha:** DataBinding classes live under `build/generated/...`, not `build/tmp/kotlin-classes`. The `classDirectories` exclusion must target the compiled output path, not source. Verify with `find build -name "*Binding.class"`.

### Kotlin Coverage Fix

Add `includeNoLocationClasses = true` to filter synthetic classes generated by Kotlin compiler:

```kotlin
tasks.withType<Test> {
  jvmArgs(
    "-noverify",
    "-ea"
  )
  extensions.configure<JacocoTaskExtension> {
    isIncludeNoLocationClasses = true
    excludes = listOf("jdk.internal.*")
  }
}
```

### Manual CLI Merging

Merge coverage files from separate test runs using `jacococli.jar`:

```bash
java -jar jacococli.jar merge \
  app/build/jacoco/testDebugUnitTest.exec \
  app/build/outputs/code-coverage/connected/*coverage.ec \
  --destfile merged-coverage.exec

java -jar jacococli.jar report merged-coverage.exec \
  --classfiles app/build/intermediates/classes/debug \
  --sourcefiles app/src/main/java \
  --html coverage-report/
```

Full CLI report generation with multiple source roots and output formats:

```bash
java -jar jacococli.jar report merged.exec \
  --classfiles build/tmp/kotlin-classes/debug \
  --sourcefiles src/main/java --sourcefiles src/main/kotlin \
  --xml coverage.xml --html coverage-html/ --csv coverage.csv
```

Coverage file locations: `.exec` for unit tests, `.ec` for instrumented tests. Known issues with GMD + coverage in AGP 8.1 (see GMD Limitations below).

### JaCoCo XML Parsing

JaCoCo XML report schema (simplified DTD):

```
report (name)
  sessioninfo (id, start, dump)
  package (name)
    class (name, sourcefilename)
      method (name, desc, line)
        counter (type, missed, covered)
      counter (type, missed, covered)
    sourcefile (name)
      line (nr, mi, ci, mb, cb)
      counter (type, missed, covered)
    counter (type, missed, covered)
  counter (type, missed, covered)     <- report-level totals
```

Counter `type` values: `INSTRUCTION`, `BRANCH`, `LINE`, `COMPLEXITY`, `METHOD`, `CLASS`.
Line attributes: `nr`=line number, `mi`/`ci`=missed/covered instructions, `mb`/`cb`=missed/covered branches.

XPath queries for coverage extraction:

```bash
# Overall line coverage percentage
xmlstarlet sel -t -v \
  "100 * //report/counter[@type='LINE']/@covered div \
  (//report/counter[@type='LINE']/@missed + //report/counter[@type='LINE']/@covered)" \
  coverage.xml

# Branch coverage per class
xmlstarlet sel -t -m "//class" -v "@name" -o ": " \
  -v "counter[@type='BRANCH']/@covered" -o "/" \
  -v "counter[@type='BRANCH']/@covered + counter[@type='BRANCH']/@missed" -n \
  coverage.xml

# Quick total extraction (no xmlstarlet needed)
grep -oP 'counter type="LINE" missed="\K[0-9]+' coverage.xml  # missed
grep -oP 'counter type="LINE".*covered="\K[0-9]+' coverage.xml # covered
```

**Gotcha:** Report-level `<counter>` elements (direct children of `<report>`) give totals. Package/class-level counters give granular data. The last `<counter>` elements in the file are the report totals.

### Per-Class Coverage Extraction

```bash
# Extract per-class LINE coverage from JaCoCo XML for a specific package
xmllint --xpath '//package[@name="com/example/feature"]/class/counter[@type="LINE"]/..' coverage.xml | \
  grep -oP 'name="\K[^"]+|missed="\K[0-9]+|covered="\K[0-9]+' | \
  paste - - -
```

Each row outputs: `ClassName  missed  covered`. The `counter[@type="LINE"]/..` XPath ensures exactly one counter per class, so `paste - - -` aligns correctly.

Python alternative: use `xml.etree.ElementTree` to parse the same XML, iterate `findall('.//package[@name="com/example/feature"]/class')`, and extract `counter[@type="LINE"]` missed/covered attributes per class.

### Coverage Thresholds in CI

```kotlin
tasks.named<JacocoCoverageVerification>("jacocoTestCoverageVerification") {
    violationRules {
        rule {
            limit { minimum = 0.80.toBigDecimal(); counter = "LINE" }
            limit { minimum = 0.60.toBigDecimal(); counter = "BRANCH" }
        }
        rule {
            element = "CLASS"
            limit { minimum = 0.70.toBigDecimal(); counter = "LINE" }
            excludes = listOf("*.Generated*", "*.BuildConfig")
        }
    }
}
```

CLI: `./gradlew jacocoTestCoverageVerification` (fails build on violation).

## Kover (JetBrains)

### Setup

```kotlin
// root build.gradle.kts
plugins {
    id("org.jetbrains.kotlinx.kover") version "0.9.7"
}
// submodules: same plugin, no version needed

// Root aggregation
dependencies {
    kover(project(":app"))
    kover(project(":core"))
    kover(project(":feature-auth"))
}
```

### Advantages Over JaCoCo for Kotlin

- Auto-creates tasks per Android build variant (no manual task registration)
- Understands Kotlin source sets natively; no classpath gymnastics
- Filter by annotation: `excludes { annotatedBy("Generated") }`
- Same report format as JaCoCo (XML compatible with SonarQube/Codecov)
- Supports `useJacoco("0.8.14")` to swap engine while keeping Kover DSL

### CLI Tasks

```bash
./gradlew koverHtmlReport          # HTML report -> build/reports/kover/html
./gradlew koverXmlReport           # XML report -> build/reports/kover/report.xml
./gradlew koverVerify              # Check thresholds
./gradlew koverLog                 # Print coverage to stdout
./gradlew koverHtmlReportDebug     # Variant-specific
```

### Verification Rules

```kotlin
kover {
    reports {
        verify {
            rule("line coverage") { minBound(80) }  // LINE + COVERED_PERCENTAGE default
            rule("branch coverage") {
                bound { minValue = 60; metric = MetricType.BRANCH }
            }
        }
        filters {
            excludes {
                classes("*Generated*", "*Dagger*", "*_Factory", "*_Impl")
                annotatedBy("androidx.compose.runtime.Composable")
            }
        }
    }
}
```

### Compose Coverage Accuracy

Both Kover and JaCoCo report artificially low branch coverage for `@Composable` functions. The Compose compiler injects a `Composer` parameter + `$changed` bitmask into every composable, creating phantom branches. Branch coverage for a simple composable with no conditionals may show ~50%.

**Workaround:** Exclude composable functions from branch coverage metrics via `annotatedBy("androidx.compose.runtime.Composable")` or measure only LINE coverage for UI code.

### Kover Compose-Specific Coverage

Isolate Compose-only coverage with Kover filters: `includes { annotatedBy("androidx.compose.runtime.Composable") }` in the `kover { reports { filters { } } }` block, then run `./gradlew koverHtmlReport`. Alternatively, generate separate reports for Compose vs non-Compose modules.

**Caveat:** Kover tracks composable function entry but does not distinguish individual recomposition branches.

## Coverage for Compose UI Tests

Compose UI tests (those using `createComposeRule()` or `createAndroidComposeRule()`) produce standard instrumented coverage files (`.ec`). What gets covered:

- **Composable function bodies** report LINE coverage accurately (each statement executes)
- **Lambda expressions** passed to composables (e.g., `onClick`, `content`) are covered when triggered during the test, but the Compose compiler wraps them in synthetic classes (`*$lambda-*`) that inflate class counts
- **Recomposition branches** created by the Compose compiler (the `$changed` bitmask checks) appear as uncovered BRANCH even when the composable runs, because the compiler generates multiple code paths for skip/recompose decisions that tests only exercise one direction of

**Recommendation:** Measure LINE coverage only for Compose UI code. Exclude `@Composable`-annotated functions from BRANCH coverage metrics (see Kover Verification Rules or JaCoCo exclusion patterns above). The `**/*ComposableSingletons*.class` and `**/*$lambda-*.class` patterns in the generated-code exclusion list handle the synthetic wrapper classes.

## Coverage for Robolectric Tests

Required config for JaCoCo to produce accurate coverage from Robolectric-executed tests:

```kotlin
android {
    testOptions {
        unitTests.all {
            it.extensions.configure<JacocoTaskExtension> {
                isIncludeNoLocationClasses = true
                excludes = listOf("jdk.internal.*") // JDK 11+ fix
            }
        }
        unitTests.isIncludeAndroidResources = true // needed for Robolectric
    }
}
```

CLI: `./gradlew testDebugUnitTest jacocoTestReport`

**Gotchas:**
- Without `isIncludeNoLocationClasses = true`, Robolectric-executed classes produce zero coverage. Standard JUnit tests in the same suite report fine.
- On JDK 11+, must also exclude `jdk.internal.*` or get `IllegalAccessError`.
- Shadow classes (Robolectric's `@Implements`) appear in coverage but are framework code; exclude `org.robolectric.**` from class directories.
- Offline instrumentation is NOT recommended; on-the-fly (JaCoCo agent) is preferred and works with Robolectric when configured correctly.

## Offline vs Online Instrumentation

JaCoCo supports **online** (default, runtime via Java agent) and **offline** (build-time bytecode rewriting) instrumentation. Offline mode is encountered with `offline = true` in JaCoCo config or legacy Robolectric setups.

Avoid offline mode: it causes class file version conflicts and breaks with frameworks that also modify bytecode (Compose compiler, Dagger/Hilt). If Robolectric coverage shows zero data, use `isIncludeNoLocationClasses = true` (see Kotlin Coverage Fix above) instead of switching to offline.

## Diff Coverage

Enforce coverage thresholds on only new/changed lines (prevents legacy uncovered code from blocking PRs).

**Plugin:** `com.form.diff-coverage` (or successor `io.github.gw-kit.delta-coverage`)

```kotlin
plugins { id("com.form.diff-coverage") version "0.9.5" }

diffCoverageReport {
    diffSource.git.compareWith("refs/remotes/origin/main")
    violationRules {
        minLines = 0.80
        minBranches = 0.60
        failOnViolation = true
    }
    reports { html = true; xml = true }
}
```

CLI: `./gradlew check diffCoverage`
Output: `build/reports/jacoco/diffCoverage/html/`

**Gotcha:** Plugin reads from JaCoCo's `jacocoTestReport` configuration by default. If using custom report tasks, wire `jacocoTestReport.executionData` explicitly.

## Multi-Module Aggregated Coverage

### Gradle Built-in (JVM only, not Android)

```kotlin
// In root build.gradle.kts
plugins { id("jacoco-report-aggregation") }
// Only aggregates from runtime classpath dependencies -- does not auto-scan all subprojects.
```

### Android-Compatible Approach

```kotlin
// In root build.gradle.kts
tasks.register<JacocoReport>("aggregatedCoverage") {
    val modules = listOf(":app", ":core", ":feature-auth", ":feature-home")
    dependsOn(modules.map { "$it:testDebugUnitTest" })

    sourceDirectories.setFrom(modules.flatMap {
        files("${project(it).projectDir}/src/main/java",
              "${project(it).projectDir}/src/main/kotlin")
    })
    classDirectories.setFrom(modules.map {
        fileTree("${project(it).layout.buildDirectory.get()}/tmp/kotlin-classes/debug") {
            exclude(generatedExclusions)
        }
    })
    executionData.setFrom(modules.flatMap {
        fileTree("${project(it).layout.buildDirectory.get()}") {
            include("jacoco/*.exec", "outputs/code-coverage/connected/*.ec")
        }
    })
    reports { xml.required.set(true); html.required.set(true) }
}
```

**Kover alternative** (simpler):
```kotlin
// root build.gradle.kts
dependencies { modules.forEach { kover(project(it)) } }
// Then: ./gradlew koverHtmlReport  <- auto-aggregates
```

## Coverage Visualization from CLI

### Badge Generation

```bash
pip install jacoco-badge-generator
python3 -m jacoco_badge_generator \
  --jacoco-csv-file build/reports/jacoco/mergedCoverageReport/mergedCoverageReport.csv \
  --badges-directory badges/
```

### Summary Statistics Extraction

```bash
# One-liner: extract line coverage % from XML
awk -F'"' '/counter type="LINE"/{printf "Line: %.1f%%\n", $6/($4+$6)*100}' coverage.xml | tail -1

# From CSV (last row = totals)
tail -1 coverage.csv | awk -F',' '{printf "Instruction: %.1f%%, Branch: %.1f%%\n", $5/($4+$5)*100, $7/($6+$7)*100}'
```

## Test Impact Analysis

No mature standalone Android tool exists. Practical approach:

1. Generate per-test coverage: JaCoCo can output per-test `.exec` files when tests run individually
2. Build a mapping: `test_name -> set(covered_classes)`
3. On code change: `git diff --name-only | map to class names | lookup which tests cover those classes`
4. Run only matched tests: `./gradlew test --tests "com.example.MatchedTest"`

**Tools:** Codecov and Thumbtack's targeted coverage approach (custom scripts intersecting git diff with JaCoCo data). No plug-and-play Gradle plugin for this yet.

## JaCoCo vs Kover Decision Matrix

| Criterion | JaCoCo | Kover |
|-----------|--------|-------|
| Kotlin accuracy | Bytecode-level, phantom branches | Same engine, better DSL |
| Compose support | Low branch accuracy | Low branch accuracy (same root cause) |
| Multi-module setup | Manual task wiring | `kover(project(...))` one-liner |
| Android variants | Manual per-variant tasks | Auto-generated per-variant |
| CI threshold gates | `jacocoTestCoverageVerification` | `koverVerify` |
| JaCoCo XML compat | Native | Full compatibility |
| Robolectric | Requires `includeNoLocationClasses` | Same requirement |
| Diff coverage | Via diff-coverage-gradle plugin | Same plugin (supports both) |

**Recommendation:** Use Kover for Kotlin-primary Android projects (simpler config, same output format). Fall back to raw JaCoCo only when Kover lacks a needed feature or for Java-heavy modules. Exclude `@Composable` functions from branch metrics regardless of tool. Gate CI on line coverage (80%+) for existing code and diff coverage (90%+) for new/changed lines.

## Gradle Managed Devices (GMD)

> **Note:** For CI-specific GMD patterns (test tiers, device groups, ATD image selection), see `ci-pipeline-config.md`.

### Device Definition

```kotlin
android {
  testOptions {
    managedDevices {
      localDevices {
        create("pixel2api30") {
          device = "Pixel 2"
          apiLevel = 30
          systemImageSource = "aosp-atd"  // or "google-atd"
        }
      }
    }
  }
}
```

### CLI

```bash
# Creates emulator, boots, runs tests, shuts down
./gradlew pixel2api30DebugAndroidTest

# With test filtering
./gradlew pixel2api30DebugAndroidTest \
  -Pandroid.testInstrumentationRunnerArguments.class=com.example.smoke.SmokeSuite

# GMD sharding
./gradlew pixel2api30DebugAndroidTest \
  -Pandroid.experimental.androidTest.numManagedDeviceShards=2

# Flaky test retry (re-run failed tests automatically)
./gradlew connectedAndroidTest \
  -Pandroid.testInstrumentationRunnerArguments.numRetries=1
```

### Device Groups (Multi-API Testing)

```kotlin
android {
  testOptions {
    managedDevices {
      localDevices {
        create("pixel2api30") {
          device = "Pixel 2"; apiLevel = 30; systemImageSource = "aosp-atd"
        }
        create("pixel2api33") {
          device = "Pixel 2"; apiLevel = 33; systemImageSource = "google-atd"
        }
      }
      groups {
        create("phoneGroup") {
          targetDevices.add(devices["pixel2api30"])
          targetDevices.add(devices["pixel2api33"])
        }
      }
    }
  }
}
```

Run group task: `./gradlew phoneGroupGroupDebugAndroidTest`

### GPU and CI Properties

```bash
# Headless CI rendering (required for swiftshader on GMD)
./gradlew pixel2api30DebugAndroidTest \
  -Pandroid.testoptions.manageddevices.emulator.gpu=swiftshader_indirect

# Intra-device parallelization (shard tests across N emulator instances)
./gradlew pixel2api30DebugAndroidTest \
  -Pandroid.experimental.androidTest.numManagedDeviceShards=4
```

Or set in `gradle.properties`:

```properties
android.testoptions.manageddevices.emulator.gpu=swiftshader_indirect
```

### Output Paths

- Test results: `build/outputs/androidTest-results/managedDevice/<device>/`
- HTML reports: `build/reports/androidTests/managedDevice/`

### CI Properties (Expanded)

Additional `gradle.properties` settings for CI environments beyond GPU rendering:

```properties
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configuration-cache=true
android.useAndroidX=true
android.testoptions.manageddevices.emulator.gpu=swiftshader_indirect
```

Use `--no-daemon` in CI to avoid orphaned daemon processes consuming memory across builds:

```bash
./gradlew pixel2api30DebugAndroidTest \
  -Pandroid.testoptions.manageddevices.emulator.gpu=swiftshader_indirect \
  --no-daemon
```

### Limitations

- ATD images lack hardware rendering; UI screenshot accuracy may differ from real devices
- Default cap: 16 concurrent emulator instances
- GMD + JaCoCo coverage has known issues in AGP 8.1

GMD integrates with Test Orchestrator via `testOptions.execution = "ANDROIDX_TEST_ORCHESTRATOR"`. Some corner cases with UTP config in early versions.

## Test Fixtures Plugin

The `java-test-fixtures` plugin creates a dedicated source set (`src/testFixtures/kotlin/`) for shared test utilities, fakes, and builders that can be consumed by other modules without leaking into production code.

### Producing Test Fixtures

```kotlin
// core/build.gradle.kts — module producing shared test resources
plugins { `java-test-fixtures` }

// Source set: src/testFixtures/kotlin/
// Place shared fakes, builders, and test data factories here
```

### Consuming Test Fixtures

```kotlin
// feature/build.gradle.kts — module consuming fixtures from :core
dependencies {
    testImplementation(testFixtures(project(":core")))
    androidTestImplementation(testFixtures(project(":core")))
}
```

**Gotcha:** `testFixtures` creates a published variant. If the producing module is included via composite builds, it must also apply `java-test-fixtures` or dependency resolution falls back silently to the main source set (fixtures not found, no error).

## Composite Builds and Test Dependencies

Include sibling projects or shared test utility libraries without publishing to a repository:

```kotlin
// settings.gradle.kts
includeBuild("../shared-test-utils")
```

CLI equivalent for ad-hoc inclusion:

```bash
./gradlew testDebugUnitTest --include-build ../shared-test-utils
```

Combine with test fixtures for a full shared-test-resources pattern:

```kotlin
// shared-test-utils/build.gradle.kts
plugins { `java-test-fixtures` }

// app/build.gradle.kts
dependencies {
    testImplementation(testFixtures(project(":shared-test-utils")))
}
```

**Gotcha:** In composite builds, the included build must also apply `java-test-fixtures` plugin if it produces fixtures. Otherwise dependency resolution fails silently, falling back to the main source set without error.

## Anti-Patterns

| DON'T | DO |
|-------|-----|
| Overuse `testTag` in production code | Prefer content descriptions and semantic labels |
| Run Compose async tests under Robolectric | Move complex `LaunchedEffect` flows to instrumented tests |
| Run screenshot tests without stable locale/font | Pin device configs and locale in Paparazzi/Roborazzi |
| Use Shot for Compose-heavy projects | Use Paparazzi or Roborazzi (no device, faster, more stable) |
| Skip test sharding on large suites | Use `numShards`/`shardIndex` or GMD shards for parallelism |
| Test implementation details (view hierarchy) | Test observable behavior via semantics |
| Call `activity.finish()` before assertions complete | Assert first, then clean up; Compose disposal races cause false failures |
| Over-mock Android types (Bundle, Parcel) in unit tests | Use Robolectric or instrumented tests; mocks hide real serialization bugs |
| Measure BRANCH coverage for Compose UI code | Use LINE coverage only; Compose compiler creates phantom branches |
| Include generated code in coverage reports | Exclude Dagger, Room, DataBinding, Compose compiler outputs |
