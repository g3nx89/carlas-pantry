# Implementation Skill Configuration
# Single source of truth for all configurable values used by the implement skill.
# Referenced by: skills/implement/SKILL.md and skills/implement/references/

# Lock protocol
lock:
  stale_timeout_minutes: 60  # Locks older than this are treated as stale and overridden

# Quality review (Stage 4)
quality_review:
  agent_count: 3  # Number of parallel reviewer agents when code-review skill is unavailable
  focus_areas:
    - "simplicity, DRY principles, and code elegance"
    - "bugs, functional correctness, and edge case handling"
    - "project conventions, abstractions, and pattern adherence"

# Severity classification (canonical definitions)
severity:
  critical:
    description: "Breaks functionality, security vulnerability, data loss risk"
    example: "Unvalidated user input in SQL query"
  high:
    description: "Likely to cause bugs, significant code quality issue"
    example: "Missing error handling on API call"
  medium:
    description: "Code smell, maintainability concern, minor pattern violation"
    example: "Duplicated logic across two files"
  low:
    description: "Style preference, minor optimization opportunity"
    example: "Variable naming inconsistency"
  # Escalation triggers: if a Medium finding matches ANY of these, promote to High.
  # Referenced by: agent-prompts.md (Quality Review Prompt), stage-4-quality-review.md (Section 4.3)
  escalation_triggers:
    - "User-visible data corruption or data loss"
    - "Implicit ordering dependency that silently produces wrong results"
    - "UI state contradiction (displayed state differs from actual state)"
    - "Singleton or shared-state leak across scopes (e.g., state carried between logical sessions)"
    - "Race condition with user-visible effect"
  # Severity ordering (for threshold comparisons): low < medium < high < critical
  # Auto-decision matrix for Stage 4 quality review coordinator.
  # Controls when to escalate to user vs auto-accept findings.
  auto_decision:
    auto_accept_low_only: true          # If ALL findings are Low, auto-accept without user prompt
    medium_auto_accept_max_count: 3     # If highest is Medium AND count <= this, auto-accept with note
    # Critical or High findings ALWAYS escalate to user — never auto-decided

# Handoff artifact tiers (Stage 1 file classification)
# Required files halt if missing. Expected files warn if missing. Optional files are silent.
handoff:
  expected_files:
    - file: "design.md"
      warning: "design.md not found — developer agents will rely on plan.md only for architecture context"
    - file: "test-plan.md"
      warning: "test-plan.md not found — TDD will proceed without a V-Model test strategy document"
  test_cases:
    subdirectories: ["e2e", "integration", "unit", "uat"]
    test_id_patterns: ["E2E-*", "INT-*", "UT-*", "UAT-*"]

# Test coverage thresholds (Stage 3 validation)
# When test-plan.md specifies planned test counts per level, Stage 3 compares actuals against these.
# Referenced by: agent-prompts.md (Completion Validation Prompt), stage-3-validation.md (Section 3.2/3.3)
test_coverage:
  thresholds:
    unit_minimum_pct: 80   # Below this → flag as High severity
    other_minimum_pct: 50  # Below this (integration, e2e) → flag as Medium severity
  # Test quality gate (Stage 3 validation check 11)
  # Patterns indicating placeholder/tautological assertions.
  # Stage 3 scans test files for these; a test file where ALL assertions
  # match tautological patterns is flagged.
  tautological_patterns:
    - "assertTrue\\(true"
    - "assert\\(true\\)"
    - "expect\\(true\\)\\.toBe\\(true\\)"
    - "expect\\(1\\)\\.toBe\\(1\\)"
    - "assertEquals\\(true,\\s*true\\)"
  # If placeholder-only test files >= this count, flag High; 1 file = Medium
  placeholder_file_threshold_high: 2

# Dev-skills integration (conditional skill injection)
# Coordinators read detected_domains from Stage 1 summary and resolve applicable skills.
# The orchestrator never reads or references these values — only coordinators do.
dev_skills:
  enabled: true
  max_skills_per_dispatch: 3  # Cap on DOMAIN skills (always_include is exempt from this cap)
  plugin_path: "dev-skills"   # Sibling plugin name — resolved as $CLAUDE_PLUGIN_ROOT/../dev-skills
  always_include:             # These are ALWAYS injected, exempt from max_skills_per_dispatch
    - skill: "clean-code"
      reason: "Universal code quality patterns (SOLID, naming, guard clauses)"
  domain_mapping:
    kotlin:
      indicators: [".kt", "Kotlin", "KMP", "kotlin"]
      skills: ["kotlin-expert"]
    compose:
      indicators: ["Composable", "Compose", "@Composable", "Material3", "LazyColumn"]
      skills: ["compose-expert"]
    android:
      indicators: ["AndroidManifest", "Activity", "ViewModel", "Intent", "android"]
      skills: ["android-expert"]
    kotlin_async:
      indicators: ["callbackFlow", "supervisorScope", "StateFlow", "SharedFlow", "suspend fun"]
      skills: ["kotlin-coroutines"]
    web_frontend:
      indicators: [".tsx", ".jsx", ".vue", ".svelte", "React", "Next.js", "CSS", "HTML"]
      skills: ["frontend-design"]
    api:
      indicators: ["endpoint", "route", "controller", "REST", "GraphQL", "handler", "/api/"]
      skills: ["api-patterns"]
    database:
      indicators: ["schema", "migration", "model", "entity", "table", "Prisma", "Drizzle", "SQL"]
      skills: ["database-schema-designer"]
    gradle:
      indicators: ["build.gradle", "settings.gradle", "version catalog", "Gradle"]
      skills: ["gradle-expert"]
  # Validation skill injection (Stage 3)
  # Injected into completion validation prompt when test-heavy features are detected
  validation_skills:
    conditional:
      - domains: ["web_frontend", "api", "database"]
        skills: ["qa-test-planner"]
  # Conditional quality review dimensions (Stage 4)
  # Added to the base focus_areas when detected_domains match
  max_conditional_reviewers: 2  # Cap on additional reviewer agents beyond base agent_count
  conditional_review:
    - domains: ["web_frontend", "compose", "android"]
      focus: "accessibility compliance, WCAG 2.1 AA, keyboard navigation, ARIA attributes, touch targets"
      skill: "accessibility-auditor"
    - domains: ["web_frontend"]
      focus: "responsive design, performance metrics, web interface best practices"
      skill: "web-design-guidelines"
  # Documentation skill injection (Stage 5)
  # Always injected for tech-writer when documentation stage runs
  documentation_skills:
    always: ["mermaid-diagrams"]
    conditional:
      - domains: ["api"]
        skills: ["api-patterns"]
      - domains: ["database"]
        skills: ["database-schema-designer"]

# Research MCP integration (conditional library/framework documentation lookup)
# Coordinators read this config and inject research context into agent prompts.
# The orchestrator never calls MCP tools — only Stage 1 (inline) probes availability,
# and coordinators build {research_context} blocks for agents.
research_mcp:
  enabled: true

  # Ref (primary) — exploits session deduplication (Dropout) for ~87% token savings
  ref:
    enabled: true
    max_searches_per_stage: 5
    max_reads_per_stage: 3
    session_accumulation: true   # URLs discovered in Stage 2 are re-read in Stages 4/5 (Ref cache serves faster)
    token_budgets:
      per_source: 2000           # Max tokens per individual source read
      research_context_total: 4000  # Max tokens for the assembled {research_context} block

  # Context7 (secondary) — used for library-specific queries, pre-resolved in Stage 1
  context7:
    enabled: true
    max_queries_per_stage: 3
    pre_resolve_in_stage1: true  # Resolve library IDs upfront so coordinators skip the resolve step
    max_pre_resolve: 5           # Max libraries to pre-resolve in Stage 1

  # Tavily (known-issues-only) — last resort for build errors and known issues
  tavily:
    enabled: true
    search_depth: "basic"
    max_results: 3
    max_searches_per_stage: 2

  # URL extraction from planning artifacts (Stage 1)
  url_extraction:
    enabled: true
    url_patterns:
      - "https?://[^\\s)>\"']+"
    ignore_patterns:
      - "github.com/.*/blob/"
      - "localhost"
      - "127.0.0.1"
      - "example.com"

  # Private documentation discovery via Ref
  private_docs:
    enabled: true
    search_scope: "private"      # Appended to Ref queries as ref_src=private
    max_private_results: 3

  # Graceful degradation — used when MCP tools are unavailable or disabled
  graceful_degradation:
    fallback_text: "No research context available — proceed with codebase knowledge and planning artifacts only."

  # Build error resolution strategy (Stage 2 error handling)
  build_error_resolution:
    enabled: true
    strategy: "ref_first"        # ref_first → escalate to Context7 → Tavily as last resort
    max_retries: 2               # Max MCP lookup attempts per build error
    escalation_after: 1          # Escalate to next tool after this many failed lookups

# Branch format
branch:
  pattern: "feature/<number-padded-to-3-digits>-<kebab-case-title>"
  example: "feature/001-user-auth"

# Auto-commit after stage milestones
# Commits are delegated to a throwaway general-purpose subagent to keep coordinator context clean.
# Failure is always warn-and-continue — a failed commit never blocks execution.
auto_commit:
  enabled: true  # Set to false to disable all auto-commits (opt-out)
  stage2_strategy: per_phase  # per_phase: commit after each phase; batch: single commit after all phases complete
  message_templates:
    phase_complete: "feat({feature_name}): implement {phase_name}"
    phase_batch: "feat({feature_name}): implement all phases"
    review_fix: "fix({feature_name}): address quality review findings"
    documentation: "docs({feature_name}): add feature documentation"
  # Exclude patterns: substring-matched against the git-status-relative file path.
  # Example: ".stage-summaries/" matches "specs/001-feature/.stage-summaries/stage-1-summary.md"
  exclude_patterns:
    - ".implementation-state.local.md"
    - ".stage-summaries/"

# Timestamp format for stage logs, state checkpoints, and summaries
timestamps:
  format: "ISO_8601"
  precision: "seconds"
  command: "date -u +%Y-%m-%dT%H:%M:%SZ"
