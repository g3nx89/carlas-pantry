# Implementation Skill Configuration
# Single source of truth for all configurable values used by the implement skill.
# Referenced by: skills/implement/SKILL.md and skills/implement/references/

# Autonomy policy (issue resolution behavior)
# Controls how the system handles findings, failures, and issues during execution.
# When default_level is null, the orchestrator asks the user at Stage 1 startup.
# When default_level is set, the question is skipped and the chosen level applies automatically.
# Referenced by: stage-1-setup.md Section 1.9a, orchestrator-loop.md, stage-2-execution.md,
#   stage-3-validation.md, stage-4-quality-review.md, stage-5-documentation.md
autonomy_policy:
  default_level: null  # null = ask at start; "full_auto" | "balanced" | "critical_only"
  levels:
    full_auto:
      label: "Full Auto"
      description: "Fix everything automatically — minimum interruptions"
      findings:
        critical: "fix"       # Auto-fix: launch fix agent
        high: "fix"           # Auto-fix: launch fix agent
        medium: "fix"         # Auto-fix: launch fix agent
        low: "accept"         # Accept silently
      incomplete_tasks: "fix"              # Auto-fix: launch developer agent to complete
      infrastructure: "retry_then_continue"  # Retry 1x, then continue with degraded state
    balanced:
      label: "Balanced"
      description: "Fix critical/high automatically, defer medium, accept low"
      findings:
        critical: "fix"       # Auto-fix: launch fix agent
        high: "fix"           # Auto-fix: launch fix agent
        medium: "defer"       # Log to review-findings.md, continue
        low: "accept"         # Accept silently
      incomplete_tasks: "document_as_is"   # Proceed to documentation noting gaps
      infrastructure: "retry_then_continue"  # Retry 1x, then continue with degraded state
    critical_only:
      label: "Minimal"
      description: "Fix only critical blockers, defer the rest"
      findings:
        critical: "fix"       # Auto-fix: launch fix agent
        high: "defer"         # Log to review-findings.md, continue
        medium: "accept"      # Accept silently
        low: "accept"         # Accept silently
      incomplete_tasks: "document_as_is"   # Proceed to documentation noting gaps
      infrastructure: "retry_then_ask"     # Retry 1x, then ask user

# Orchestrator settings
# Referenced by: orchestrator-loop.md step 6 (cumulative failure check)
orchestrator:
  max_coordinator_failures: 3  # Halt with diagnostic when cumulative coordinator failures reach this threshold

# Lock protocol
lock:
  stale_timeout_minutes: 60  # Locks older than this are treated as stale and overridden

# Quality review (Stage 4)
quality_review:
  agent_count: 3  # Number of parallel reviewer agents when code-review skill is unavailable
  focus_areas:
    - "simplicity, DRY principles, and code elegance"
    - "bugs, functional correctness, and edge case handling"
    - "project conventions, abstractions, and pattern adherence"

  # CoVe (Chain-of-Verification) post-synthesis (Stage 4)
  # Dispatches throwaway subagent to verify Critical/High findings against actual code.
  # Referenced by: stage-4-quality-review.md Section 4.3b
  cove:
    enabled: false
    min_findings_trigger: 2           # Min Critical+High findings to trigger CoVe
    verification_questions:
      min: 3
      max: 5

  # Reviewer stance assignment for calibrated scoring (Stage 4)
  # Referenced by: stage-4-quality-review.md Section 4.2, agent-prompts.md
  stances:
    enabled: false
    assignments:
      - stance: "advocate"
        prompt_extension: "Highlight code strengths, acknowledge good patterns, give benefit of doubt on ambiguous choices. Your role is to ensure genuine quality is recognized, not to inflate scores."
      - stance: "challenger"
        prompt_extension: "Actively find gaps, risks, overlooked failure modes, and edge cases. Score conservatively. Your role is to stress-test the implementation, not to be unfair."
      - stance: "neutral"
        prompt_extension: ""
    divergence:
      low_threshold: 0               # Same severity: accept majority
      moderate_threshold: 1           # 1 level diff: accept and note
      high_threshold: 2               # 2+ levels: flag for user

  # Native agent failure tracking (Stage 4)
  # Referenced by: stage-4-quality-review.md Section 4.2
  native_agent_failure_threshold: 3  # Consecutive developer agent failures before surfacing diagnostic

  # Convergence detection for reviewer agreement (Stage 4)
  # Referenced by: stage-4-quality-review.md Section 4.3a
  convergence:
    enabled: false
    high_threshold: 0.70
    medium_threshold: 0.40
    keyword_count: 20
    strategies:
      high: "standard_merge_deduplicate"
      medium: "weighted_merge_flag_divergence"
      low: "present_all_flag_for_user"

# Severity classification (canonical definitions)
severity:
  critical:
    description: "Breaks functionality, security vulnerability, data loss risk"
    example: "Unvalidated user input in SQL query"
  high:
    description: "Likely to cause bugs, significant code quality issue"
    example: "Missing error handling on API call"
  medium:
    description: "Code smell, maintainability concern, minor pattern violation"
    example: "Duplicated logic across two files"
  low:
    description: "Style preference, minor optimization opportunity"
    example: "Variable naming inconsistency"
  # Escalation triggers: if a Medium finding matches ANY of these, promote to High.
  # Referenced by: agent-prompts.md (Quality Review Prompt), stage-4-quality-review.md (Section 4.3)
  escalation_triggers:
    - "User-visible data corruption or data loss"
    - "Implicit ordering dependency that silently produces wrong results"
    - "UI state contradiction (displayed state differs from actual state)"
    - "Singleton or shared-state leak across scopes (e.g., state carried between logical sessions)"
    - "Race condition with user-visible effect"
  # Severity ordering (for threshold comparisons): low < medium < high < critical
  # Auto-decision matrix for Stage 4 quality review coordinator.
  # Controls when to escalate to user vs auto-accept findings.
  auto_decision:
    auto_accept_low_only: true          # If ALL findings are Low, auto-accept without user prompt
    medium_auto_accept_max_count: 3     # If highest is Medium AND count <= this, auto-accept with note
    # Critical or High findings ALWAYS escalate to user — never auto-decided

# Handoff artifact tiers (Stage 1 file classification)
# Required files halt if missing. Expected files warn if missing. Optional files are silent.
handoff:
  expected_files:
    - file: "design.md"
      warning: "design.md not found — developer agents will rely on plan.md only for architecture context"
    - file: "test-plan.md"
      warning: "test-plan.md not found — TDD will proceed without a V-Model test strategy document"
  optional_files:
    - file: "test-strategy.md"
      description: "Strategic test analysis from specify — risks, testable ACs, critical journeys, edge cases"
  test_cases:
    subdirectories: ["e2e", "integration", "unit", "uat"]
    test_id_patterns: ["E2E-*", "INT-*", "UT-*", "UAT-*"]

# Test coverage thresholds (Stage 3 validation)
# When test-plan.md specifies planned test counts per level, Stage 3 compares actuals against these.
# Referenced by: agent-prompts.md (Completion Validation Prompt), stage-3-validation.md (Section 3.2/3.3)
test_coverage:
  thresholds:
    unit_minimum_pct: 80   # Below this → flag as High severity
    other_minimum_pct: 50  # Below this (integration, e2e) → flag as Medium severity
  # Test quality gate (Stage 3 validation check 11)
  # Patterns indicating placeholder/tautological assertions.
  # Stage 3 scans test files for these; a test file where ALL assertions
  # match tautological patterns is flagged.
  tautological_patterns:
    - "assertTrue\\(true"
    - "assert\\(true\\)"
    - "expect\\(true\\)\\.toBe\\(true\\)"
    - "expect\\(1\\)\\.toBe\\(1\\)"
    - "assertEquals\\(true,\\s*true\\)"
  # If placeholder-only test files >= this count, flag High; 1 file = Medium
  placeholder_file_threshold_high: 2

# Dev-skills integration (conditional skill injection)
# Coordinators read detected_domains from Stage 1 summary and resolve applicable skills.
# The orchestrator never reads or references these values — only coordinators do.
dev_skills:
  enabled: true
  max_skills_per_dispatch: 3  # Cap on DOMAIN skills (always_include is exempt from this cap)
  plugin_path: "dev-skills"   # Sibling plugin name — resolved as $CLAUDE_PLUGIN_ROOT/../dev-skills
  always_include:             # These are ALWAYS injected, exempt from max_skills_per_dispatch
    - skill: "clean-code"
      reason: "Universal code quality patterns (SOLID, naming, guard clauses)"
  domain_mapping:
    kotlin:
      indicators: [".kt", "Kotlin", "KMP", "kotlin"]
      skills: ["kotlin-expert"]
    compose:
      indicators: ["Composable", "Compose", "@Composable", "Material3", "LazyColumn"]
      skills: ["compose-expert"]
    android:
      indicators: ["AndroidManifest", "Activity", "ViewModel", "Intent", "android"]
      skills: ["android-expert"]
    kotlin_async:
      indicators: ["callbackFlow", "supervisorScope", "StateFlow", "SharedFlow", "suspend fun"]
      skills: ["kotlin-coroutines"]
    web_frontend:
      indicators: [".tsx", ".jsx", ".vue", ".svelte", "React", "Next.js", "CSS", "HTML"]
      skills: ["frontend-design"]
    api:
      indicators: ["endpoint", "route", "controller", "REST", "GraphQL", "handler", "/api/"]
      skills: ["api-patterns"]
    database:
      indicators: ["schema", "migration", "model", "entity", "table", "Prisma", "Drizzle", "SQL"]
      skills: ["database-schema-designer"]
    gradle:
      indicators: ["build.gradle", "settings.gradle", "version catalog", "Gradle"]
      skills: ["gradle-expert"]
  # Validation skill injection (Stage 3)
  # Injected into completion validation prompt when test-heavy features are detected
  validation_skills:
    conditional:
      - domains: ["web_frontend", "api", "database"]
        skills: ["qa-test-planner"]
  # Conditional quality review dimensions (Stage 4)
  # Added to the base focus_areas when detected_domains match
  max_conditional_reviewers: 2  # Cap on additional reviewer agents beyond base agent_count
  conditional_review:
    - domains: ["web_frontend", "compose", "android"]
      focus: "accessibility compliance, WCAG 2.1 AA, keyboard navigation, ARIA attributes, touch targets"
      skill: "accessibility-auditor"
    - domains: ["web_frontend"]
      focus: "responsive design, performance metrics, web interface best practices"
      skill: "web-design-guidelines"
  # Documentation skill injection (Stage 5)
  # Always injected for tech-writer when documentation stage runs
  documentation_skills:
    always: ["mermaid-diagrams"]
    conditional:
      - domains: ["api"]
        skills: ["api-patterns"]
      - domains: ["database"]
        skills: ["database-schema-designer"]

# Research MCP integration (conditional library/framework documentation lookup)
# Coordinators read this config and inject research context into agent prompts.
# The orchestrator never calls MCP tools — only Stage 1 (inline) probes availability,
# and coordinators build {research_context} blocks for agents.
research_mcp:
  enabled: true

  # Ref (primary) — exploits session deduplication (Dropout) for ~87% token savings
  ref:
    enabled: true
    max_searches_per_stage: 5
    max_reads_per_stage: 3
    session_accumulation: true   # URLs discovered in Stage 2 are re-read in Stages 4/5 (Ref cache serves faster)
    token_budgets:
      per_source: 2000           # Max tokens per individual source read
      research_context_total: 4000  # Max tokens for the assembled {research_context} block

  # Context7 (secondary) — used for library-specific queries, pre-resolved in Stage 1
  context7:
    enabled: true
    max_queries_per_stage: 3
    pre_resolve_in_stage1: true  # Resolve library IDs upfront so coordinators skip the resolve step
    max_pre_resolve: 5           # Max libraries to pre-resolve in Stage 1

  # Tavily (known-issues-only) — last resort for build errors and known issues
  tavily:
    enabled: true
    search_depth: "basic"
    max_results: 3
    max_searches_per_stage: 2

  # URL extraction from planning artifacts (Stage 1)
  url_extraction:
    enabled: true
    url_patterns:
      - "https?://[^\\s)>\"']+"
    ignore_patterns:
      - "github.com/.*/blob/"
      - "localhost"
      - "127.0.0.1"
      - "example.com"

  # Private documentation discovery via Ref
  private_docs:
    enabled: true
    search_scope: "private"      # Appended to Ref queries as ref_src=private
    max_private_results: 3

  # Graceful degradation — used when MCP tools are unavailable or disabled
  graceful_degradation:
    fallback_text: "No research context available — proceed with codebase knowledge and planning artifacts only."

  # Build error resolution strategy (Stage 2 error handling)
  build_error_resolution:
    enabled: true
    strategy: "ref_first"        # ref_first → escalate to Context7 → Tavily as last resort
    max_retries: 2               # Max MCP lookup attempts per build error
    escalation_after: 1          # Escalate to next tool after this many failed lookups

# Branch format
branch:
  pattern: "feature/<number-padded-to-3-digits>-<kebab-case-title>"
  example: "feature/001-user-auth"

# Auto-commit after stage milestones
# Commits are delegated to a throwaway general-purpose subagent to keep coordinator context clean.
# Failure is always warn-and-continue — a failed commit never blocks execution.
auto_commit:
  enabled: true  # Set to false to disable all auto-commits (opt-out)
  stage2_strategy: per_phase  # per_phase: commit after each phase; batch: single commit after all phases complete
  message_templates:
    phase_complete: "feat({feature_name}): implement {phase_name}"
    phase_batch: "feat({feature_name}): implement all phases"
    review_fix: "fix({feature_name}): address quality review findings"
    documentation: "docs({feature_name}): add feature documentation"
    retrospective: "docs({feature_name}): add implementation retrospective"
  # Exclude patterns: substring-matched against the git-status-relative file path.
  # Example: ".stage-summaries/" matches "specs/001-feature/.stage-summaries/stage-1-summary.md"
  exclude_patterns:
    - ".implementation-state.local.md"
    - ".stage-summaries/"
    - ".implementation-report-card"
    - "transcript-extract.json"

# Code simplification (Stage 2 post-phase)
# When enabled, a code-simplifier agent runs after each phase's developer agent completes.
# The simplifier refines modified files for clarity and maintainability while preserving functionality.
# Rollback is safe because simplification runs before auto-commit (git checkout reverts cleanly).
# Referenced by: stage-2-execution.md Step 3.5
code_simplification:
  enabled: true                     # Set to false to skip simplification entirely
  scope: "phase_modified_files"     # Only files modified in the current phase
  exclude_patterns:                 # Substring-matched against file paths — skip these files
    - ".test."
    - ".spec."
    - "__tests__/"
    - "test/"
    - ".md"
    - ".json"
    - ".yaml"
    - ".yml"
  max_files_per_phase: 15           # Skip simplification if more files modified (likely infra/config phase)
  test_verification: true           # Run full test suite after simplification (always recommended)
  rollback_on_test_failure: true    # Revert all simplification changes if any test fails

# UAT mobile testing (Stage 2 per-phase)
# When enabled, runs behavioral acceptance scenarios and Figma visual verification
# against a running app on a Genymotion emulator after each relevant phase.
# Requires: Genymotion emulator running, mobile-mcp MCP server available, Gemini CLI installed.
# Referenced by: stage-1-setup.md Section 1.6e, stage-2-execution.md Step 3.7
uat_execution:
  enabled: true                          # Master switch (also requires cli_dispatch.stage2.uat_mobile_tester.enabled)
  emulator:
    platform: "android"                  # "android" | "ios" (future)
    launch_timeout_ms: 30000             # Wait for device to appear in mobile_list_available_devices
  apk_install:
    reinstall: true                      # Uninstall before install to ensure clean state
    launch_after_install: true           # Launch app after install
    app_package: null                    # Auto-detected from APK; override if needed

# CLI dispatch configuration (Bash process-group dispatch)
# All CLI features are opt-in (enabled: false by default).
# Native agent behavior is the default for every stage.
# Requires: target CLI installed, config/cli_clients/ directory with role prompt files,
#           scripts/dispatch-cli-agent.sh for process-group-safe dispatch.
#
# CLI agents are standalone processes without MCP server access. Budgets are advisory
# prompt text. Coordinators pre-fetch via Subagent-Delegated Context Injection.
# Codex CLI may read .mcp.json for limited MCP support; Gemini CLI has no MCP.
cli_dispatch:

  # --- GLOBAL SETTINGS ---

  timeout_ms: 300000              # 5 minute default; per-option override available
  timeout_action: "fallback"      # "fallback" (use native/skip) | "error" (halt with user prompt)
  retry:
    max_attempts: 1               # Number of retries on transient failure (0 = no retry)
    backoff_ms: 5000              # Wait between retries

  # Instrumentation — metrics sidecar written alongside each CLI dispatch output
  instrumentation:
    enabled: true                   # Write .metrics.json sidecar with timing, tier, exit code, CLI version
    capture_cli_version: true       # Include CLI tool version string in sidecar
    sidecar_retention: "session"    # "session" = cleaned up in Stage 6; "permanent" = kept indefinitely

  # Non-skippable gates — dispatches that autonomy policy cannot auto-skip
  non_skippable_gates:
    - "stage2.uat_mobile_tester"    # UAT behavioral testing cannot be auto-skipped even under full_auto policy

  # Cross-stage circuit breaker for CLI dispatch failures
  # Referenced by: stage-1-setup.md Section 1.7b, cli-dispatch-procedure.md
  circuit_breaker:
    enabled: false
    consecutive_failure_threshold: 3

  # MCP tool budgets per CLI dispatch (advisory limits on MCP usage by CLI agents).
  # Injected into CLI agent prompts by coordinators. These are prompt-based guidance,
  # not programmatic hard caps — CLI agents receive the budget as text instructions.
  # Coordinators can verify compliance post-dispatch by counting MCP tool references in output.
  # Structure mirrors research_mcp config for naming parity.
  mcp_tool_budgets:
    per_cli_dispatch:
      ref:
        max_searches: 3          # Max ref_search_documentation calls per dispatch
        max_reads: 2             # Max ref_read_url calls per dispatch
      context7:
        max_queries: 2           # Max query-docs calls per dispatch (resolve-library-id is free)
      tavily:
        max_searches: 2          # Max tavily_search / tavily_research calls per dispatch
      sequential_thinking:
        max_chains: 1            # Max sequentialthinking chains per dispatch
      figma:
        max_calls: 5             # UAT mobile tester uses get_design_context + get_screenshot for visual verification
      mobile_mcp:
        max_screenshots: 10      # Max mobile_take_screenshot calls per dispatch
        max_interactions: 50     # Max click/swipe/type calls per dispatch
        max_device_queries: 3    # Max list_devices/list_elements calls per dispatch

  # --- STAGE 2 ---

  stage2:
    # Option A: Delegate per-phase code generation to external coding agent (Tier 3 — deferred)
    phase_developer:
      enabled: false
      cli_name: "codex"
      role: "phase_developer"
      fallback_to_native: true

    # Option B: Pre-implementation API/framework documentation research (Tier 3 — deferred)
    api_researcher:
      enabled: false
      cli_name: "gemini"
      role: "api_researcher"
      max_tokens: 2000
      trigger_keywords: ["API", "SDK", "migration", "v2", "upgrade", "new version"]

    # Option H: Test-first generation from test-case specs (Tier 1)
    test_author:
      enabled: false
      cli_name: "codex"
      role: "test_author"
      requires_test_cases: true     # Static prerequisite: only activate if test-cases/ exists
      allow_developer_adjustments: true  # Developer can fix imports/setup in generated tests

    # Option I: Post-implementation edge case test augmentation (Tier 1)
    test_augmenter:
      enabled: false
      cli_name: "gemini"
      role: "test_augmenter"
      max_additional_tests: 10
      focus: ["boundary", "error", "concurrency", "security"]

    # Option J: Per-phase UAT mobile testing via Genymotion + Figma visual verification (Tier 1)
    # Runs behavioral acceptance scenarios and visual fidelity checks against a running app
    # on a Genymotion emulator after each relevant phase completes in Stage 2.
    # Requires: uat_execution.enabled, Gemini CLI, mobile-mcp MCP server, running emulator.
    uat_mobile_tester:
      enabled: false
      cli_name: "gemini"
      role: "uat_mobile_tester"
      fallback_behavior: "skip"          # skip silently if Gemini unavailable, mobile-mcp unreachable, or no emulator
      # Phase relevance detection — determines which phases trigger UAT
      phase_relevance:
        check_uat_test_ids: true         # Check task descriptions for UAT-* test IDs mapped to test-cases/uat/
        check_ui_file_paths: true        # Check task file paths against UI domain indicators
        ui_domains: ["compose", "android", "web_frontend"]  # Domains from dev_skills.domain_mapping whose indicators suggest UI work
      # Gradle build configuration — builds installable APK before UAT
      gradle_build:
        command: "./gradlew assembleDebug"
        apk_search_pattern: "**/build/outputs/apk/debug/*.apk"
        timeout_ms: 180000               # 3 minutes for Gradle build
      # Figma visual verification — compare running app against Figma designs
      figma:
        enabled: true                    # Enable Figma design comparison alongside behavioral testing
        default_node_url: null           # Optional: static default Figma URL; UAT specs can override per-scenario via figma_url: in YAML frontmatter
        visual_mismatch_threshold: "medium"  # Severity assigned to visual mismatches: "medium" | "high"
      # Finding severity gating — controls phase progression
      severity_gating:
        block_on: ["critical", "high"]   # Halt phase progression for these severities (status: needs-user-input)
        warn_on: ["medium", "low"]       # Log warning, continue for these
      # Screenshot evidence storage
      evidence_dir: ".uat-evidence"      # Relative to FEATURE_DIR; screenshots stored per phase as {evidence_dir}/{phase_name_sanitized}/
      # Timeout for the CLI dispatch itself (overrides global cli_dispatch.timeout_ms)
      timeout_ms: 600000                 # 10 minutes — UAT scenarios with mobile-mcp interactions take longer than code review

    # Option K: Post-phase UX test coverage review via OpenCode (Tier 2)
    # Reviews test files after each phase for UX scenario coverage gaps:
    # empty states, loading states, error states, accessibility assertions.
    # Only triggers for phases with UI-related file paths.
    ux_test_reviewer:
      enabled: false
      cli_name: "opencode"
      role: "ux_test_reviewer"
      fallback_behavior: "skip"          # Skip silently if OpenCode unavailable
      phase_relevance:
        check_ui_file_paths: true        # Check task file paths against UI domain indicators
        ui_domains: ["compose", "android", "web_frontend"]  # Domains from dev_skills.domain_mapping whose indicators suggest UI work

  # --- STAGE 3 ---

  stage3:
    # Option C: Cross-model specification validation (Tier 2)
    spec_validator:
      enabled: false
      cli_name: "gemini"
      role: "spec_validator"
      merge_strategy: "conservative"  # Use lower test count, flag disagreements

    # Option D: UX/Accessibility validation via OpenCode (Tier 2)
    # Validates implementation completeness from UX perspective: user flow states,
    # accessibility attributes, error recovery paths. Runs in parallel with native
    # validator and Gemini spec validator.
    ux_validator:
      enabled: false
      cli_name: "opencode"
      role: "ux_validator"
      merge_strategy: "conservative"  # UX gaps added to merged finding set; disagreements marked "NEEDS MANUAL REVIEW"

  # --- STAGE 4 ---

  stage4:
    # Option D: Tier C multi-model CLI code review — runs alongside Tier A native agents (Tier 1)
    multi_model_review:
      enabled: false
      reviewers:
        - focus: "bugs, functional correctness, and edge case handling"
          cli_name: "codex"
          role: "correctness_reviewer"
        - focus: "project conventions, abstractions, and pattern adherence"
          cli_name: null              # null = native developer agent
          role: null
      # Conditional reviewers — launched alongside base reviewers when domain/severity conditions are met
      conditional:
        - focus: "security vulnerabilities, OWASP Top 10"
          cli_name: "codex"
          role: "security_reviewer"
          domains: ["api", "web_frontend", "database"]
        - focus: "Android lifecycle, Compose recomposition, Material 3, coroutine safety"
          cli_name: "gemini"
          role: "android_domain_reviewer"
          domains: ["android", "compose", "kotlin"]
        - focus: "UX quality, accessibility compliance, user flow completeness"
          cli_name: "opencode"
          role: "ux_reviewer"
          domains: ["compose", "android", "web_frontend"]
      # Codebase pattern reviewer — Phase 2 sequential dispatch (requires Phase 1 Critical/High findings)
      codebase_pattern_reviewer:
        dispatch_phase: 2             # Runs after Phase 1 consolidation, only if Critical/High findings exist
        cli_name: "gemini"
        role: "codebase_pattern_reviewer"
        context_strategy: "full_codebase"  # Leverages Gemini's 1M context window
        max_context_tokens: 800000    # Advisory cap for codebase content injected into prompt
      # Pattern search — controls Phase 2 trigger threshold
      pattern_search:
        min_severity_trigger: "high"  # Phase 2 pattern search only runs if Phase 1 has findings at this severity or above
      # Confidence scoring — progressive threshold filtering for multi-tier findings
      confidence_scoring:
        base_score: 40                # Starting confidence for any finding
        consensus_bonus: 25           # Bonus when 2+ tiers flag the same issue
        file_line_bonus: 15           # Bonus when finding includes exact file:line reference
        snippet_bonus: 10             # Bonus when finding includes code snippet
        known_pattern_bonus: 10       # Bonus when finding matches a known anti-pattern
        thresholds:                   # Minimum confidence to retain finding at each severity
          critical: 50
          high: 65
          medium: 75
          low: 90
      # Review plugins — Tier B plugin-based review via code-review skill
      review_plugins:
        enabled: true                 # Check for code-review:review-local-changes skill availability
        max_findings: 50              # Cap on findings from plugin review
        # Confidence mapping — normalizes CEK plugin confidence+impact to Stage 4 severity.
        # Canonical source for stage-4-plugin-review.md normalization table.
        confidence_mapping:
          critical:
            min_confidence: 0.9
            impact: "high"
            condition: "Security or data-loss concern"
          high:
            min_confidence: 0.8
            impact: "high"
            condition: "Likely bug or significant issue"
          medium:
            min_confidence: 0.7
            impact: "any"             # OR impact = "medium" (whichever matches first)
            condition: "Code smell or pattern concern"
          low:
            condition: "All others — style or optimization suggestion"

    # Option F: Fix review findings with different model (Tier 2)
    fix_engineer:
      enabled: false
      cli_name: "codex"
      role: "fix_engineer"
      fallback_to_native: true

  # --- STAGE 5 ---

  stage5:
    # Option G: Documentation research before tech-writer dispatch (Tier 3 — deferred)
    doc_researcher:
      enabled: false
      cli_name: "gemini"
      role: "doc_researcher"
      max_tokens: 1500

    # Option L: Documentation quality review via OpenCode (Tier 2)
    # Reviews documentation produced by tech-writer from user perspective:
    # completeness, accuracy, usability, accessibility documentation.
    # Runs AFTER tech-writer produces docs, findings fed back for optional revision.
    doc_reviewer:
      enabled: false
      cli_name: "opencode"
      role: "doc_reviewer"
      fallback_behavior: "skip"          # Skip silently if OpenCode unavailable

# Implementation retrospective (Stage 6)
# Generates a KPI Report Card and narrative retrospective document after all stages complete.
# Stage 6 runs post-lock-release (read-only analysis). No lock operations needed.
# Referenced by: stage-6-retrospective.md
retrospective:
  enabled: true                         # Set to false to skip Stage 6 entirely
  transcript_analysis:
    enabled: true                       # Set to false to skip session transcript extraction
    transcript_dir: null                # null = auto-detect from ~/.claude/projects/
    max_errors_extracted: 20            # Cap on tool errors in transcript extract
    max_file_paths_extracted: 50        # Cap on files_most_accessed in transcript extract
    extract_token_budget: 3000          # Approximate token budget for transcript-extract.json
  sections:                             # Toggle retrospective document sections
    timeline: true
    what_worked: true
    what_didnt_work: true
    stage_breakdown: true
    tool_analysis: true
    code_quality_metrics: true
    recommendations: true
    raw_metrics: true

# Timestamp format for stage logs, state checkpoints, and summaries
timestamps:
  format: "ISO_8601"
  precision: "seconds"
  command: "date -u +%Y-%m-%dT%H:%M:%SZ"

# Context Pack Protocol — accumulated context propagation across stages
# Referenced by: orchestrator-loop.md DISPATCH_COORDINATOR
context_protocol:
  enabled: false
  total_budget_tokens: 600  # Post-formatting validation: truncate lowest-priority items if total exceeds this
  category_budgets:
    decisions: 250
    open_issues: 200
    risk_signals: 150
  truncation_strategies:
    decisions: "keep_high_confidence_first"
    open_issues: "keep_highest_severity_first"
    risk_signals: "keep_highest_severity_first"
